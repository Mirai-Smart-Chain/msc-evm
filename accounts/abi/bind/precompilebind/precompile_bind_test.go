// (c) 2019-2020, Ava Labs, Inc.
//
// This file is a derived work, based on the go-ethereum library whose original
// notices appear below.
//
// It is distributed under a license compatible with the licensing terms of the
// original code from which it is derived.
//
// Much love to the original authors for their work.
// **********
// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package precompilebind

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"github.com/ava-labs/subnet-evm/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/require"
)

var bindTests = []struct {
	name     string
	contract string
	abi      []string
	imports  string
	tester   string
	errMsg   string
}{
	{
		"AnonOutputChecker",
		"",
		[]string{`
			[
				{"type":"function","name":"anonOutput","constant":true,"inputs":[],"outputs":[{"name":"","type":"string"}]}
			]
		`},
		"",
		"",
		"ABI outputs for anonOutput require a name to generate the precompile binding, re-generate the ABI from a Solidity source file with all named outputs",
	},
	{
		"AnonOutputsChecker",
		"",
		[]string{`
			[
				{"type":"function","name":"anonOutputs","constant":true,"inputs":[],"outputs":[{"name":"","type":"string"},{"name":"","type":"string"}]}
			]
		`},
		"",
		"",
		"ABI outputs for anonOutputs require a name to generate the precompile binding, re-generate the ABI from a Solidity source file with all named outputs",
	},
	{
		"MixedOutputsChecker",
		"",
		[]string{`
			[
				{"type":"function","name":"mixedOutputs","constant":true,"inputs":[],"outputs":[{"name":"","type":"string"},{"name":"str","type":"string"}]}
			]
		`},
		"",
		"",
		"ABI outputs for mixedOutputs require a name to generate the precompile binding, re-generate the ABI from a Solidity source file with all named outputs",
	},
	// Test that module is generated correctly
	{
		`EmptyContract`,
		`contract EmptyContract {}`,
		[]string{`[]`},
		`"github.com/stretchr/testify/require"`,
		`
			require.Equal(t, "emptyContractConfig", Module.ConfigKey)
		`,
		"",
	},
	{
		`HelloWorld`,
		`interface IHelloWorld is IAllowList {
			// sayHello returns the stored greeting string
			function sayHello() external view returns (string calldata result);

			// setGreeting  stores the greeting string
			function setGreeting(string calldata response) external;
		}
		`,
		[]string{`[{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"readAllowList","outputs":[{"internalType":"uint256","name":"role","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"sayHello","outputs":[{"internalType":"string","name":"result","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"setEnabled","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"response","type":"string"}],"name":"setGreeting","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"setNone","outputs":[],"stateMutability":"nonpayable","type":"function"}]`},
		`"github.com/stretchr/testify/require"`,
		`
			testGreeting := "test"
			method := HelloWorldABI.Methods["setGreeting"]
			packedGreeting, err := method.Inputs.Pack(testGreeting)
			require.NoError(t, err)
			unpackedGreeting, err := UnpackSetGreetingInput(packedGreeting)
			require.NoError(t, err)
			require.Equal(t, testGreeting, unpackedGreeting)
		`,
		"",
	},
}

// Tests that packages generated by the binder can be successfully compiled and
// the requested tester run against it.
func TestPrecompileBind(t *testing.T) {
	// Skip the test if no Go command can be found
	gocmd := runtime.GOROOT() + "/bin/go"
	if !common.FileExist(gocmd) {
		t.Skip("go sdk not found for testing")
	}
	// Create a temporary workspace for the test suite
	ws := t.TempDir()

	pkg := filepath.Join(ws, "bindtest")
	if err := os.MkdirAll(pkg, 0o700); err != nil {
		t.Fatalf("failed to create package: %v", err)
	}
	// Generate the test suite for all the contracts
	for i, tt := range bindTests {
		t.Run(tt.name, func(t *testing.T) {
			types := []string{tt.name}

			// Generate the binding and create a Go source file in the workspace
			bindedFiles, err := PrecompileBind(types, tt.abi, []string{""}, nil, tt.name, bind.LangGo, nil, nil, "contract.abi", true)
			if tt.errMsg != "" {
				require.ErrorContains(t, err, tt.errMsg)
				return
			}
			if err != nil {
				t.Fatalf("test %d: failed to generate binding: %v", i, err)
			}
			precompilePath := filepath.Join(pkg, tt.name)
			if err := os.MkdirAll(precompilePath, 0o700); err != nil {
				t.Fatalf("failed to create package: %v", err)
			}
			// change address to a suitable one for testing
			bindedFiles.Module = strings.Replace(bindedFiles.Module, `common.HexToAddress("{ASUITABLEHEXADDRESS}")`, `common.HexToAddress("0x03000000000000000000000000000000000000ff")`, 1)
			if err = os.WriteFile(filepath.Join(precompilePath, "module.go"), []byte(bindedFiles.Module), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}
			if err = os.WriteFile(filepath.Join(precompilePath, "config.go"), []byte(bindedFiles.Config), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}
			if err = os.WriteFile(filepath.Join(precompilePath, "contract.go"), []byte(bindedFiles.Contract), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}
			if err = os.WriteFile(filepath.Join(precompilePath, "contract_test.go"), []byte(bindedFiles.ConfigTest), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}
			if err = os.WriteFile(filepath.Join(precompilePath, "contract_test.go"), []byte(bindedFiles.ContractTest), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}
			if err = os.WriteFile(filepath.Join(precompilePath, "contract.abi"), []byte(tt.abi[0]), 0o600); err != nil {
				t.Fatalf("test %d: failed to write binding: %v", i, err)
			}

			// Generate the test file with the injected test code
			code := fmt.Sprintf(`
			package %s

			import (
				"testing"
				%s
			)

			func Test%s(t *testing.T) {
				%s
			}
		`, tt.name, tt.imports, tt.name, tt.tester)
			if err := os.WriteFile(filepath.Join(precompilePath, strings.ToLower(tt.name)+"_test.go"), []byte(code), 0o600); err != nil {
				t.Fatalf("test %d: failed to write tests: %v", i, err)
			}
		})
	}

	moder := exec.Command(gocmd, "mod", "init", "bindtest")
	moder.Dir = pkg
	if out, err := moder.CombinedOutput(); err != nil {
		t.Fatalf("failed to convert binding test to modules: %v\n%s", err, out)
	}
	pwd, _ := os.Getwd()
	replacer := exec.Command(gocmd, "mod", "edit", "-x", "-require", "github.com/ava-labs/subnet-evm@v0.0.0", "-replace", "github.com/ava-labs/subnet-evm="+filepath.Join(pwd, "..", "..", "..", "..")) // Repo root
	replacer.Dir = pkg
	if out, err := replacer.CombinedOutput(); err != nil {
		t.Fatalf("failed to replace binding test dependency to current source tree: %v\n%s", err, out)
	}
	tidier := exec.Command(gocmd, "mod", "tidy", "-compat=1.19")
	tidier.Dir = pkg
	if out, err := tidier.CombinedOutput(); err != nil {
		t.Fatalf("failed to tidy Go module file: %v\n%s", err, out)
	}
	// Test the entire package and report any failures
	cmd := exec.Command(gocmd, "test", "./...", "-v", "-count", "1")
	cmd.Dir = pkg
	if out, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("failed to run binding test: %v\n%s", err, out)
	}
}
