// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package sharedmemory

import (
	"bytes"
	"errors"
	"fmt"
	"math/big"

	"github.com/ava-labs/avalanchego/chains/atomic"
	"github.com/ava-labs/avalanchego/ids"
	"github.com/ava-labs/avalanchego/snow"
	"github.com/ava-labs/avalanchego/vms/components/avax"
	"github.com/ava-labs/avalanchego/vms/secp256k1fx"
	"github.com/ava-labs/subnet-evm/precompile/precompileconfig"
	"github.com/ava-labs/subnet-evm/utils/codec"
	"github.com/ethereum/go-ethereum/common"
)

var (
	_ precompileconfig.Config               = &Config{}
	_ precompileconfig.Accepter             = &Config{}
	_ precompileconfig.PrecompilePredicater = &Config{}
)

// Config implements the precompileconfig.Config interface and
// adds specific configuration for SharedMemory.
type Config struct {
	precompileconfig.Upgrade
	// CUSTOM CODE STARTS HERE
	// Add your own custom fields for Config here
}

// NewConfig returns a config for a network upgrade at [blockTimestamp] that enables
// SharedMemory.
func NewConfig(blockTimestamp *big.Int) *Config {
	return &Config{
		Upgrade: precompileconfig.Upgrade{BlockTimestamp: blockTimestamp},
	}
}

// NewDisableConfig returns config for a network upgrade at [blockTimestamp]
// that disables SharedMemory.
func NewDisableConfig(blockTimestamp *big.Int) *Config {
	return &Config{
		Upgrade: precompileconfig.Upgrade{
			BlockTimestamp: blockTimestamp,
			Disable:        true,
		},
	}
}

// Key returns the key for the SharedMemory precompileconfig.
// This should be the same key as used in the precompile module.
func (*Config) Key() string { return ConfigKey }

// Verify tries to verify Config and returns an error accordingly.
func (c *Config) Verify() error {
	// CUSTOM CODE STARTS HERE
	// Add your own custom verify code for Config here
	// and return an error accordingly
	return nil
}

// Equal returns true if [s] is a [*Config] and it has been configured identical to [c].
func (c *Config) Equal(s precompileconfig.Config) bool {
	// typecast before comparison
	other, ok := (s).(*Config)
	if !ok {
		return false
	}
	// CUSTOM CODE STARTS HERE
	// modify this boolean accordingly with your custom Config, to check if [other] and the current [c] are equal
	// if Config contains only Upgrade you can skip modifying it.
	equals := c.Upgrade.Equal(&other.Upgrade)
	return equals
}

// Accept will be called for every log with the address of the precompile when the block is accepted.
func (c *Config) Accept(acceptCtx *precompileconfig.AcceptContext, txHash common.Hash, logIndex int, topics []common.Hash, logData []byte) error {
	chainID, requests, err := acceptedLogsToSharedMemoryOps(acceptCtx.SnowCtx, txHash, logIndex, topics, logData)
	if err != nil {
		return err
	}
	acceptCtx.SharedMemory.AddSharedMemoryRequests(chainID, requests)
	return nil
}

// acceptedLogsToSharedMemoryOps processes the event's log data and topics, and returns a
// chainID and the atomic requests that should be sent to the shared memory for that chain.
func acceptedLogsToSharedMemoryOps(snowCtx *snow.Context, txHash common.Hash, logIndex int, topics []common.Hash, logData []byte) (ids.ID, *atomic.Requests, error) {
	if len(topics) == 0 {
		return ids.ID{}, nil, errors.New("SharedMemory does not handle logs with 0 topics")
	}
	event, err := SharedMemoryABI.EventByID(topics[0]) // First topic is the event ID
	if err != nil {
		return ids.ID{}, nil, fmt.Errorf("shared memory accept: %w", err)
	}

	// TODO: separate this out better and implement remaining handlers
	switch event.Name {
	case "ExportUTXO":
		return handleExportUTXO(snowCtx, txHash, logIndex, topics, logData)
	case "ExportAVAX":
		return handleExportAVAX(snowCtx, txHash, logIndex, topics, logData)
	case "ImportUTXO":
		return handleImportUTXO(snowCtx, txHash, logIndex, topics, logData)
	case "ImportAVAX":
		return handleImportAVAX(snowCtx, txHash, logIndex, topics, logData)
	default:
		return ids.ID{}, nil, fmt.Errorf("shared memory accept unexpected log: %q", event.Name)
	}
}

// TODO: consider changing this to specify a single UTXO and allowing the predicate to unmarshal a slice
// of pairs (SourceChainID, UTXO)
type AtomicPredicate struct {
	// Which chain to consume the funds from
	SourceChain ids.ID `serialize:"true" json:"sourceChain"`
	// UTXOs consumable in this transaction
	ImportedUTXOs []*avax.UTXO `serialize:"true" json:"importedInputs"`
}

// VerifyPredicate verifies that the UTXOs specified by [predicateBytes] are present in shared memory, valid, and
// have not been consumed yet.
// VerifyPredicate is called before the transaction execution, so it is up to the precompile implementation to validate
// that the caller has permission to consume the UTXO and how consuming the UTXO works.
func (c *Config) VerifyPredicate(predicateContext *precompileconfig.PrecompilePredicateContext, predicateBytes []byte) error {
	atomicPredicate := new(AtomicPredicate)
	version, err := codec.Codec.Unmarshal(predicateBytes, atomicPredicate)
	if err != nil {
		return fmt.Errorf("failed to unmarshal shared memory predicate: %w", err)
	}
	if version != codec.CodecVersion {
		return fmt.Errorf("invalid version for shared memory predicate: %d", version)
	}

	utxoIDs := make([][]byte, len(atomicPredicate.ImportedUTXOs))
	for i, in := range atomicPredicate.ImportedUTXOs {
		inputID := in.UTXOID.InputID()
		utxoIDs[i] = inputID[:]
	}
	// allUTXOBytes is guaranteed to be the same length as utxoIDs
	allUTXOBytes, err := predicateContext.SnowCtx.SharedMemory.Get(atomicPredicate.SourceChain, utxoIDs)
	if err != nil {
		return fmt.Errorf("failed to fetch import UTXOs from %s due to: %w", atomicPredicate.SourceChain, err)
	}

	// TODO: check that the UTXO has not been marked as consumed within the statedb

	for i, specifiedUTXO := range atomicPredicate.ImportedUTXOs {
		specifiedUTXOBytes, err := codec.Codec.Marshal(codec.CodecVersion, specifiedUTXO)
		if err != nil {
			return fmt.Errorf("failed to marshal specified UTXO: %s", specifiedUTXO.ID)
		}
		utxoBytes := allUTXOBytes[i]

		if !bytes.Equal(specifiedUTXOBytes, utxoBytes) {
			return fmt.Errorf("UTXO %s mismatching byte representation: 0x%x expected: 0x%x", specifiedUTXO.ID, specifiedUTXOBytes, utxoBytes)
		}

		// Validate that the specified UTXO is valid to be imported to the EVM
		transferOut, ok := specifiedUTXO.Out.(*secp256k1fx.TransferOutput)
		if !ok {
			return fmt.Errorf("UTXO %s invalid UTXO output type: %T", specifiedUTXO.ID, specifiedUTXO.Out)
		}
		// Do not allow a transfer amount of 0 - no VM should export an atomic UTXO with an amount of 0, so this
		// should never happen, but just in case another VM implements this incorrectly, we add an extra check here
		if transferOut.Amt == 0 {
			return fmt.Errorf("UTXO %s cannot specify an amount of 0", specifiedUTXO.ID)
		}
		// When import is called within the EVM, there will only be one caller address, so we require a threshold of 1
		// since a UTXO with a threshold of 2 will never be valid to import.
		if transferOut.Threshold != 1 {
			return fmt.Errorf("UTXO %s specified invalid threshold", specifiedUTXO.ID)
		}
	}

	return nil
}
